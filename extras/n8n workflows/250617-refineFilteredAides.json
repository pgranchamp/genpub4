{
  "name": "refineFilteredAides",
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "=Tu es un expert en aides publiques et en financement de projets. Ton rôle est d'analyser la pertinence d'une aide publique par rapport à un projet spécifique.\n\nPROJET À ANALYSER :\n- Description du projet : {{ $('UniverselParse').item.json.receivedData.body.projectContext.reformulation }}\n- Mots-clés du projet : {{ $('UniverselParse').item.json.receivedData.body.projectContext.keywords }}\n- Secteur d'activité de l'organisation : {{ $('UniverselParse').item.json.receivedData.body.projectContext.key_elements }}\n\nAIDE PUBLIQUE À ÉVALUER :\n- Titre de l'aide :{{ $('Parser').item.json.titre }} \n- Porteur de l'aide : {{ $('Parser').item.json.porteur_aide }}\n- Description : {{ $('Parser').item.json.description }}\n- Bénéficiaires éligibles : {{ $('Parser').item.json.beneficiaires }}\n- Types de financement : {{ $('Parser').item.json.types_financement }}\n- Montant : {{ $('Parser').item.json.montant }}\n- Dépenses éligibles : {{ $('Parser').item.json.depenses_eligibles }}\n- Modalités d'intervention : {{ $('Parser').item.json.modalites_intervention }}\n- Finalité : {{ $('Parser').item.json.finalite }}\n- Critères d'éligibilité : {{ $('Parser').item.json.criteres_eligibilite }}\n- Zone géographique : {{ $('Parser').item.json.zone_geographique }}\n- Thématiques de l'aide : {{ $('Parser').item.json.thematiques }}\n\nDÉTAIL COMPLÉMENTAIRE DE L'AIDE :\n{{ $json.corps_principal }}\nMISSION :\nAnalyse la compatibilité entre le projet et cette aide publique. Évalue le niveau de pertinence selon cette échelle :\n- \"PAS PERTINENTE DU TOUT\" : Aucune correspondance, secteurs ou objectifs incompatibles\n- \"PAS PERTINENTE\" : Correspondance faible, critères d'éligibilité non remplis\n- \"PERTINENTE\" : Correspondance correcte, aide utilisable avec quelques adaptations\n- \"TRÈS PERTINENTE\" : Correspondance excellente, aide parfaitement adaptée au projet\n\nRÉPONSE OBLIGATOIREMENT AU FORMAT JSON :\n{\n  \"niveau_pertinence\": \"[PAS PERTINENTE DU TOUT|PAS PERTINENTE|PERTINENTE|TRÈS PERTINENTE]\",\n  \"score_compatibilite\": [0-100],\n  \"justification\": \"Explication détaillée de ton analyse en 2-3 phrases\",\n  \"points_positifs\": [\"Point 1\", \"Point 2\", \"Point 3\"],\n  \"points_negatifs\": [\"Point 1\", \"Point 2\"],\n  \"recommandations\": \"Conseils pour améliorer la compatibilité ou confirmer l'adéquation\"\n}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        680,
        365.5
      ],
      "id": "0996cbb6-9826-4a48-a575-b56152a41b87",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "chatgpt-4o-latest",
          "mode": "list",
          "cachedResultName": "chatgpt-4o-latest"
        },
        "options": {
          "maxTokens": 2000,
          "responseFormat": "json_object",
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        768,
        585.5
      ],
      "id": "8e723e06-4785-464c-8744-ef4bc3f99c5a",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "AaBAEkezuocD9zVb",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{ $json.receivedData.body.aideDetails.url }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            },
            {}
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -420,
        280
      ],
      "id": "87c7bc24-c72c-4db4-931c-95f85df1234a",
      "name": "HTTP Request1",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.3,
      "position": [
        1276,
        365.5
      ],
      "id": "abe72cb6-5a9d-4b14-bb55-93beb844d2fe",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "refineFilteredAides",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -860,
        180
      ],
      "id": "be049e3d-12d2-48d1-b0b8-dbd40b032580",
      "name": "Webhook1",
      "webhookId": "937e255c-bab5-4f8b-8fa5-3eb4f6f48c58"
    },
    {
      "parameters": {
        "url": "={{ $json.url_plus_infos }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            },
            {}
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        240,
        605
      ],
      "id": "84adc1da-5c3c-4ed1-a22b-64b27603333f",
      "name": "URL_plus_info",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parser généraliste pour pages url_plus_infos (Bpifrance, etc.)\nconst inputData = $input.first().json;\n\nconsole.log('=== PARSER URL_PLUS_INFOS ===');\n\ntry {\n  // Récupération du HTML depuis HTTP Request\n  const html = inputData.data || inputData.body || inputData.html || inputData.content || '';\n  console.log('HTML length:', html.length);\n  \n  if (!html) {\n    return [{\n      json: {\n        error: true,\n        message: \"Aucun contenu HTML reçu\"\n      }\n    }];\n  }\n\n  // Fonction utilitaire pour nettoyer le texte\n  function cleanText(text) {\n    if (!text) return '';\n    return text\n      .replace(/<[^>]+>/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .replace(/&[^;]+;/g, ' ')\n      .trim();\n  }\n\n  const result = {};\n\n  // 1. TITRE DE LA PAGE\n  const titleMatch = html.match(/<title[^>]*>([^<]+)/i);\n  result.titre = titleMatch ? cleanText(titleMatch[1]) : 'Titre non trouvé';\n\n  // 2. META DESCRIPTION\n  const metaDescPattern = /<meta[^>]*name=[\"']description[\"'][^>]*content=[\"']([^\"']+)[\"']/i;\n  const metaDescMatch = html.match(metaDescPattern);\n  result.meta_description = metaDescMatch ? cleanText(metaDescMatch[1]) : '';\n\n  // 3. META KEYWORDS (si présentes)\n  const metaKeywordsPattern = /<meta[^>]*name=[\"']keywords[\"'][^>]*content=[\"']([^\"']+)[\"']/i;\n  const metaKeywordsMatch = html.match(metaKeywordsPattern);\n  result.meta_keywords = metaKeywordsMatch ? cleanText(metaKeywordsMatch[1]) : '';\n\n  // 4. META AUTHOR (si présent)\n  const metaAuthorPattern = /<meta[^>]*name=[\"']author[\"'][^>]*content=[\"']([^\"']+)[\"']/i;\n  const metaAuthorMatch = html.match(metaAuthorPattern);\n  result.meta_author = metaAuthorMatch ? cleanText(metaAuthorMatch[1]) : '';\n\n  // 5. TITRE PRINCIPAL (H1)\n  const h1Pattern = /<h1[^>]*>([^<]+)<\\/h1>/i;\n  const h1Match = html.match(h1Pattern);\n  result.titre_principal = h1Match ? cleanText(h1Match[1]) : '';\n\n  // 6. SOUS-TITRES IMPORTANTS (H2, H3)\n  const sousTitres = [];\n  const hPattern = /<h[2-3][^>]*>([^<]+)<\\/h[2-3]>/gi;\n  const hMatches = [...html.matchAll(hPattern)];\n  \n  hMatches.forEach(match => {\n    const titre = cleanText(match[1]);\n    if (titre.length > 3 && titre.length < 150) {\n      sousTitres.push(titre);\n    }\n  });\n  result.sous_titres = sousTitres.slice(0, 10); // Limiter à 10\n\n  // 7. EXTRACTION DU CORPS PRINCIPAL\n  let corpsPrincipal = html;\n\n  // Supprimer les éléments non-informatifs\n  corpsPrincipal = corpsPrincipal\n    // Scripts, styles, navigation\n    .replace(/<script[^>]*>.*?<\\/script>/gis, ' ')\n    .replace(/<style[^>]*>.*?<\\/style>/gis, ' ')\n    .replace(/<nav[^>]*>.*?<\\/nav>/gis, ' ')\n    .replace(/<header[^>]*>.*?<\\/header>/gis, ' ')\n    .replace(/<footer[^>]*>.*?<\\/footer>/gis, ' ')\n    .replace(/<aside[^>]*>.*?<\\/aside>/gis, ' ')\n    \n    // Éléments techniques\n    .replace(/<!--.*?-->/gs, ' ')\n    .replace(/<meta[^>]*>/gi, ' ')\n    .replace(/<link[^>]*>/gi, ' ')\n    .replace(/<noscript[^>]*>.*?<\\/noscript>/gis, ' ')\n    \n    // Navigation et menus\n    .replace(/<div[^>]*class=\"[^\"]*menu[^\"]*\"[^>]*>.*?<\\/div>/gis, ' ')\n    .replace(/<div[^>]*class=\"[^\"]*nav[^\"]*\"[^>]*>.*?<\\/div>/gis, ' ')\n    .replace(/<div[^>]*class=\"[^\"]*breadcrumb[^\"]*\"[^>]*>.*?<\\/div>/gis, ' ')\n    .replace(/<ul[^>]*class=\"[^\"]*nav[^\"]*\"[^>]*>.*?<\\/ul>/gis, ' ')\n    \n    // Formulaires de newsletter/abonnement\n    .replace(/<form[^>]*>.*?<\\/form>/gis, ' ')\n    \n    // Supprimer toutes les balises HTML\n    .replace(/<[^>]+>/g, ' ')\n    \n    // Nettoyage final\n    .replace(/&[^;]+;/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .replace(/\\n\\s*\\n/g, '\\n')\n    .trim();\n\n  // Limiter la taille du corps (environ 3000 caractères)\n  if (corpsPrincipal.length > 3000) {\n    const cutPosition = corpsPrincipal.lastIndexOf(' ', 3000);\n    corpsPrincipal = corpsPrincipal.substring(0, cutPosition > 2500 ? cutPosition : 3000) + '...';\n  }\n\n  result.corps_principal = corpsPrincipal;\n\n  // 8. LIENS EXTERNES IMPORTANTS\n  const liensExternes = [];\n  const linkPattern = /<a[^>]+href=[\"']([^\"']+)[\"'][^>]*>(.*?)<\\/a>/gis;\n  const linkMatches = [...html.matchAll(linkPattern)];\n  \n  linkMatches.forEach(match => {\n    const url = match[1];\n    const text = cleanText(match[2]);\n    \n    // Garder uniquement les liens externes significatifs\n    if (url && text && \n        url.startsWith('http') && \n        text.length > 5 && text.length < 100 &&\n        !text.toLowerCase().includes('cookie') &&\n        !text.toLowerCase().includes('mention') &&\n        !text.toLowerCase().includes('politique')) {\n      \n      liensExternes.push(`${text} : ${url}`);\n    }\n  });\n  \n  result.liens_externes = liensExternes.slice(0, 8); // Limiter\n\n  // 9. MÉTADONNÉES TECHNIQUES\n  result.url_source = inputData.url || '';\n  result.taille_html = html.length;\n  result.extraction_date = new Date().toISOString();\n\n  // 10. SCORE DE QUALITÉ DU CONTENU\n  let scoreQualite = 0;\n  if (result.titre.length > 10) scoreQualite += 20;\n  if (result.meta_description.length > 20) scoreQualite += 15;\n  if (result.titre_principal.length > 5) scoreQualite += 15;\n  if (result.corps_principal.length > 500) scoreQualite += 25;\n  if (result.sous_titres.length > 2) scoreQualite += 15;\n  if (result.liens_externes.length > 1) scoreQualite += 10;\n\n  result.score_qualite = scoreQualite;\n  result.error = false;\n\n  console.log('Extraction terminée - Score qualité:', scoreQualite);\n  console.log('Taille corps principal:', result.corps_principal.length);\n\n  // RETOUR OBLIGATOIRE AVEC .json pour n8n\n  return [{\n    json: {\n      titre: result.titre,\n      meta_description: result.meta_description,\n      meta_keywords: result.meta_keywords,\n      meta_author: result.meta_author,\n      titre_principal: result.titre_principal,\n      sous_titres: result.sous_titres,\n      corps_principal: result.corps_principal,\n      liens_externes: result.liens_externes,\n      url_source: result.url_source,\n      taille_html: result.taille_html,\n      extraction_date: result.extraction_date,\n      score_qualite: result.score_qualite,\n      error: result.error\n    }\n  }];\n\n} catch (error) {\n  console.error('Erreur dans le parser:', error);\n  return [{\n    json: {\n      error: true,\n      message: 'Erreur lors de l\\'extraction des données',\n      details: error.message\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        605
      ],
      "id": "d1f9c716-cf86-42db-99ec-97d2f185ff4e",
      "name": "Code"
    },
    {
      "parameters": {
        "jsCode": "// Parser complet pour pages aides-territoires avec extraction structurée\nconst inputData = $input.first().json;\n\nconsole.log('=== PARSER STRUCTURÉ AIDES-TERRITOIRES ===');\n\ntry {\n  // Récupération du HTML depuis HTTP Request\n  const html = inputData.data || inputData.body || inputData.html || inputData.content || '';\n  console.log('HTML length:', html.length);\n  \n  if (!html) {\n    return [{\n      json: {\n        error: true,\n        message: \"Aucun contenu HTML reçu\"\n      }\n    }];\n  }\n\n  // Fonction utilitaire pour nettoyer le texte\n  function cleanText(text) {\n    if (!text) return '';\n    return text\n      .replace(/<[^>]+>/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .replace(/&[^;]+;/g, ' ')\n      .trim();\n  }\n\n  // Fonction pour extraire le texte après un label\n  function extractAfterLabel(html, label, maxLength = 500) {\n    const pattern = new RegExp(label + '[^>]*>\\\\s*([^<]+)', 'i');\n    const match = html.match(pattern);\n    return match ? cleanText(match[1]).substring(0, maxLength) : '';\n  }\n\n  // EXTRACTION DES DONNÉES STRUCTURÉES\n  const result = {};\n\n  // 1. TITRE DE L'AIDE\n  const titleMatch = html.match(/<title[^>]*>([^<]+)/i) || \n                    html.match(/<h1[^>]*>([^<]+)<\\/h1>/i);\n  result.titre = titleMatch ? \n    cleanText(titleMatch[1]).replace(/\\s*\\|\\s*Aides-territoires.*$/, '') : \n    'Titre non trouvé';\n\n  // 2. PORTEUR D'AIDE (correction pour structure avec lien)\n  const porteurPatterns = [\n    // Pattern principal basé sur la structure réelle\n    /Porteur\\(s\\)\\s*d'aide[^>]*>.*?<a[^>]*>([^<]+)<\\/a>/is,\n    /PORTEUR D'AIDE[^>]*>.*?<a[^>]*>([^<]+)<\\/a>/is,\n    // Pattern pour le lien direct vers partenaires\n    /<a[^>]*href=\"\\/partenaires\\/[^\"]*\"[^>]*>([^<]+)<\\/a>/i,\n    // Fallback sur l'alt de l'image\n    /<img[^>]*alt=\"logo\\s+([^\"]+)\"/i,\n    // Pattern plus générique\n    /class=\"[^\"]*porteur[^\"]*\"[^>]*>.*?<a[^>]*>([^<]+)<\\/a>/is\n  ];\n  \n  result.porteur_aide = '';\n  for (let pattern of porteurPatterns) {\n    const match = html.match(pattern);\n    if (match) {\n      let porteur = cleanText(match[1]);\n      // Nettoyer les mots parasites mais garder le nom\n      if (porteur.length > 2 && !porteur.toLowerCase().includes('ouvrir')) {\n        result.porteur_aide = porteur;\n        break;\n      }\n    }\n  }\n\n  // 3. DESCRIPTION (correction)\n  const descPatterns = [\n    /<meta[^>]*name=[\"']description[\"'][^>]*content=[\"']([^\"']+)/i,\n    /Description[^>]*>\\s*<[^>]*>\\s*([^<]+)/i,\n    /Description[^>]*>\\s*([^<]+)/i,\n    // Pattern spécifique pour \"La BPI participe...\"\n    /La\\s+BPI\\s+participe[^.]+\\./i\n  ];\n  \n  result.description = '';\n  for (let pattern of descPatterns) {\n    const match = html.match(pattern);\n    if (match) {\n      let desc = cleanText(match[1] || match[0]);\n      // Éviter les descriptions génériques\n      if (desc.length > 10 && \n          !desc.toLowerCase().includes('aides territoires') &&\n          !desc.toLowerCase().includes('trouvez des aides')) {\n        result.description = desc;\n        break;\n      }\n    }\n  }\n\n  // 4. TYPES DE FINANCEMENT (correction - nettoyage)\n  const financementTypes = [];\n  \n  // Patterns plus précis pour éviter la pollution\n  const typeTexts = ['Subvention', 'Avance récupérable', 'Ingénierie financière', 'Prêt'];\n  \n  typeTexts.forEach(typeText => {\n    // Chercher le type avec son détail\n    const pattern = new RegExp(`${typeText}[^>]*>\\\\s*([^<\\\\n]+)`, 'i');\n    const match = html.match(pattern);\n    \n    if (match) {\n      let detail = cleanText(match[1]);\n      // Nettoyer les détails parasites\n      if (detail && detail.length > 3 && \n          !detail.includes('target=') && \n          !detail.includes('href=') &&\n          !detail.includes('subventionnes')) {\n        financementTypes.push(detail);\n      }\n    } else if (html.toLowerCase().includes(typeText.toLowerCase())) {\n      // Si trouvé sans détail, ajouter juste le type\n      financementTypes.push(typeText);\n    }\n  });\n  \n  result.types_financement = [...new Set(financementTypes)]; // Dédupliquer\n\n  // 5. MONTANT/PLAFOND\n  const montantPatterns = [\n    /plafonnée?\\s*à\\s*([0-9\\s,\\.]+)\\s*[€euros]/i,\n    /montant[^0-9]*([0-9\\s,\\.]+)\\s*[€euros]/i,\n    /jusqu'à\\s*([0-9\\s,\\.]+)\\s*[€euros]/i,\n    /([0-9\\s,\\.]+)\\s*€/i\n  ];\n  \n  result.montant = '';\n  for (let pattern of montantPatterns) {\n    const match = html.match(pattern);\n    if (match) {\n      result.montant = match[0].trim();\n      break;\n    }\n  }\n\n  // 6. RÉCURRENCE\n  const recurrencePattern = /Récurrence[^>]*>([^<]+)/i;\n  const recurrenceMatch = html.match(recurrencePattern);\n  result.recurrence = recurrenceMatch ? cleanText(recurrenceMatch[1]) : '';\n\n  // 7. BÉNÉFICIAIRES (correction)\n  const beneficiairePatterns = [\n    /Bénéficiaires[^>]*>\\s*([^<\\n]+)/i,\n    /Entreprises? éligibles?[^>]*>\\s*([^<\\n]+)/i,\n    /Entreprise privée/i,\n    /class=\"[^\"]*beneficiaire[^\"]*\"[^>]*>\\s*([^<\\n]+)/i\n  ];\n  \n  result.beneficiaires = '';\n  for (let pattern of beneficiairePatterns) {\n    const match = html.match(pattern);\n    if (match) {\n      result.beneficiaires = cleanText(match[1] || match[0]);\n      if (result.beneficiaires.length > 3) break;\n    }\n  }\n\n  // 8. ZONE GÉOGRAPHIQUE (correction)\n  const zonePatterns = [\n    /Zone géographique[^>]*>\\s*([^<\\n]+)/i,\n    /Zone géographique couverte par l'aide[^>]*>\\s*([^<\\n]+)/i,\n    // Fallback pour \"France\" visible dans l'image\n    /France(?!\\s*(métropolitaine|relance))/i\n  ];\n  \n  result.zone_geographique = '';\n  for (let pattern of zonePatterns) {\n    const match = html.match(pattern);\n    if (match) {\n      result.zone_geographique = cleanText(match[1] || match[0]);\n      if (result.zone_geographique.length > 2) break;\n    }\n  }\n\n  // 9. DÉPENSES ÉLIGIBLES\n  const depensesPattern = /Dépenses éligibles[^>]*>(.*?)(?=<h|$)/is;\n  const depensesMatch = html.match(depensesPattern);\n  result.depenses_eligibles = depensesMatch ? \n    cleanText(depensesMatch[1]).substring(0, 1000) : '';\n\n  // 10. MODALITÉS D'INTERVENTION\n  const modalitesPattern = /Modalités d'intervention[^>]*>(.*?)(?=<h|$)/is;\n  const modalitesMatch = html.match(modalitesPattern);\n  result.modalites_intervention = modalitesMatch ? \n    cleanText(modalitesMatch[1]).substring(0, 1000) : '';\n\n  // 11. FINALITÉ\n  const finalitePattern = /Finalité[^>]*>(.*?)(?=<h|$)/is;\n  const finaliteMatch = html.match(finalitePattern);\n  result.finalite = finaliteMatch ? \n    cleanText(finaliteMatch[1]).substring(0, 1000) : '';\n\n  // 11. CRITÈRES D'ÉLIGIBILITÉ (correction)\n  const criteresPattern = /Critères d'éligibilité[^>]*>(.*?)(?=<h[1-6]|<section|<footer|$)/is;\n  const criteresMatch = html.match(criteresPattern);\n  let criteresText = '';\n  \n  if (criteresMatch) {\n    criteresText = cleanText(criteresMatch[1]);\n  } else {\n    // Fallback: chercher les patterns spécifiques visibles dans l'image\n    const criteresPatterns = [\n      /Dépenses\\/actions couvertes[^>]*>([^<]+)/i,\n      /Autres critères d'éligibilité[^>]*>([^<]+)/i,\n      /Vous innovez avec[^.]+\\./i\n    ];\n    \n    const criteresFragments = [];\n    criteresPatterns.forEach(pattern => {\n      const match = html.match(pattern);\n      if (match) {\n        criteresFragments.push(cleanText(match[0]));\n      }\n    });\n    criteresText = criteresFragments.join(' ');\n  }\n  \n  result.criteres_eligibilite = criteresText.substring(0, 1000);\n\n  // 13. THÉMATIQUES (correction - cibler uniquement la sidebar)\n  const thematiques = [];\n  \n  // Chercher spécifiquement dans la zone \"Thématiques\" de la sidebar\n  const thematiquesSectionPattern = /Thématiques[^>]*>(.*?)(?=<h[1-6]|<section|<footer|Dernière mise à jour)/is;\n  const thematiquesSectionMatch = html.match(thematiquesSectionPattern);\n  \n  if (thematiquesSectionMatch) {\n    const thematiqueContent = thematiquesSectionMatch[1];\n    \n    // Extraire les liens dans cette section spécifique\n    const thematiquePattern = /<a[^>]*href=\"[^\"]*\"[^>]*>([^<]+)<\\/a>/gi;\n    const thematiqueMatches = [...thematiqueContent.matchAll(thematiquePattern)];\n    \n    thematiqueMatches.forEach(match => {\n      const text = cleanText(match[1]);\n      // Filtrer pour garder seulement les vraies thématiques\n      if (text.length > 8 && text.length < 100 && \n          !text.toLowerCase().includes('connexion') &&\n          !text.toLowerCase().includes('inscription') &&\n          !text.toLowerCase().includes('contenu') &&\n          !text.toLowerCase().includes('pied') &&\n          !text.toLowerCase().includes('accueil') &&\n          !text.toLowerCase().includes('cartographie') &&\n          !text.toLowerCase().includes('portail') &&\n          !text.toLowerCase().includes('actualité') &&\n          !text.toLowerCase().includes('programme') &&\n          !text.toLowerCase().includes('europe') &&\n          !text.toLowerCase().includes('se connecter') &&\n          !text.toLowerCase().includes('trouver') &&\n          !text.toLowerCase().includes('diffuser')) {\n        thematiques.push(text);\n      }\n    });\n  } else {\n    // Fallback: chercher les thématiques par patterns spécifiques visibles\n    const thematiquesFallback = [\n      'Innovation, créativité et recherche',\n      'Information voyageur, billettique multimodale', \n      'Transports collectifs et optimisation des trafics routiers',\n      'Mobilité partagée',\n      'Logistique urbaine',\n      'Mobilité pour tous',\n      'Connaissance de la mobilité',\n      'Modes actifs : vélo, marche et aménagements associés',\n      'Limiter les déplacements subis'\n    ];\n    \n    // Vérifier lesquelles sont présentes dans le HTML\n    thematiquesFallback.forEach(thematique => {\n      if (html.toLowerCase().includes(thematique.toLowerCase())) {\n        thematiques.push(thematique);\n      }\n    });\n  }\n  \n  result.thematiques = [...new Set(thematiques)].slice(0, 15); // Dédupliquer et limiter\n\n  // 14. DERNIÈRE MISE À JOUR\n  const majPattern = /Dernière mise à jour[^>]*>([^<]+)/i;\n  const majMatch = html.match(majPattern);\n  result.derniere_maj = majMatch ? cleanText(majMatch[1]) : '';\n\n  // 15. URL PLUS D'INFORMATIONS (le fameux bouton)\n  let url_plus_infos = null;\n  \n  // Pattern spécifique pour le bouton avec classe origin_url_btn\n  const originUrlPattern = /<a[^>]*class=\"[^\"]*origin_url_btn[^\"]*\"[^>]*href=[\"']([^\"']+)[\"']/i;\n  const originUrlMatch = html.match(originUrlPattern);\n  \n  if (originUrlMatch) {\n    url_plus_infos = originUrlMatch[1];\n  } else {\n    // Fallback: chercher \"Plus d'informations\" avec flag multiline\n    const plusInfoPattern = /<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>(.*?)<\\/a>/gis;\n    const plusInfoMatches = [...html.matchAll(plusInfoPattern)];\n    \n    for (let match of plusInfoMatches) {\n      const text = cleanText(match[2]);\n      const url = match[1];\n      \n      if (text.toLowerCase().includes('plus') && \n          text.toLowerCase().includes('info') &&\n          url.startsWith('http') && \n          !url.includes('aides-territoires')) {\n        url_plus_infos = url;\n        break;\n      }\n    }\n  }\n  \n  result.url_plus_infos = url_plus_infos || '';\n\n  // 16. CONTACT (correction - cibler le vrai contact de l'aide)\n  let contactInfo = '';\n  \n  // Supprimer d'abord tout le JSON-LD qui pollue\n  const htmlSansJsonLd = html.replace(/<script[^>]*type=[\"']application\\/ld\\+json[\"'][^>]*>.*?<\\/script>/gis, '');\n  \n  const contactPatterns = [\n    // Pattern principal pour \"Contactez directement la [ORGANISME]\"\n    /Contactez directement[^<]*<\\/a>/i,\n    /Contactez directement[^>]*>([^<]+)/i,\n    // Pattern pour les liens de contact externes (pas les liens relatifs)\n    /<a[^>]*href=\"(https?:\\/\\/[^\"]*)\"[^>]*>[^<]*[Cc]ontact[^<]*<\\/a>/i,\n    // Pattern pour le texte \"Contactez directement\" \n    /Contactez directement la ([^<\\n]+)/i,\n    // Pattern pour section Contact complète\n    /<h[1-6][^>]*>Contact<\\/h[1-6]>[^<]*<[^>]*>[^<]*<a[^>]*href=\"([^\"]*)\"[^>]*>([^<]+)<\\/a>/is\n  ];\n  \n  for (let pattern of contactPatterns) {\n    const match = htmlSansJsonLd.match(pattern);\n    if (match) {\n      // Si c'est une URL complète, la garder\n      if (match[1] && match[1].startsWith('http')) {\n        contactInfo = `Contact : ${match[2] || 'Lien externe'} (${match[1]})`;\n        break;\n      }\n      // Si c'est du texte, le garder\n      else if (match[1] && !match[1].startsWith('/')) {\n        contactInfo = cleanText(match[1] || match[0]);\n        break;\n      }\n      // Si c'est le match complet du texte \"Contactez directement\"\n      else if (match[0] && !match[0].includes('/contact/')) {\n        contactInfo = cleanText(match[0]);\n        break;\n      }\n    }\n  }\n  \n  // Si on a trouvé seulement un lien relatif générique, chercher autre chose\n  if (!contactInfo || contactInfo.includes('/contact/')) {\n    // Chercher un email spécifique\n    const emailPattern = /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/g;\n    const emails = htmlSansJsonLd.match(emailPattern) || [];\n    \n    if (emails.length > 0) {\n      contactInfo = `Email : ${emails[0]}`;\n    } else {\n      // Fallback : indiquer le type de contact trouvé\n      contactInfo = \"Contactez directement l'organisme porteur\";\n    }\n  }\n  \n  result.contact = contactInfo.substring(0, 200); // Limiter la taille\n  \n  // Extraire emails du contact nettoyé\n  const emailPattern = /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/g;\n  const emails = contactInfo.match(emailPattern) || [];\n  result.emails_contact = [...new Set(emails)]; // Dédupliquer\n\n  // 17. URL DE LA PAGE\n  result.url_source = inputData.url || '';\n\n  console.log('Extraction terminée:', Object.keys(result).length, 'champs extraits');\n  console.log('URL plus d\\'infos trouvée:', !!result.url_plus_infos);\n\n  return [{\n    json: {\n      ...result,\n      error: false,\n      extraction_date: new Date().toISOString()\n    }\n  }];\n\n} catch (error) {\n  console.error('Erreur dans le parser:', error);\n  return [{\n    json: {\n      error: true,\n      message: 'Erreur lors de l\\'extraction des données',\n      details: error.message\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -200,
        280
      ],
      "id": "719ed10d-ee6c-4cd7-bb95-9e4375b9ddfe",
      "name": "Parser"
    },
    {
      "parameters": {
        "operation": "pdf",
        "binaryPropertyName": "{{ $json.url_plus_infos }}",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        460,
        405
      ],
      "id": "3eb87937-1bf5-414a-9d5e-41f2f5717af7",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.url_plus_infos }}",
                    "rightValue": ".pdf",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    },
                    "id": "7011882c-900a-4c57-84fe-494aff4a3734"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Extract from File"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f371b0c1-15a4-4e3b-8369-055f0ce0544f",
                    "leftValue": "={{ $json.url_plus_infos }}",
                    "rightValue": ".PDF",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Extract from File"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "d95563dd-5702-4fa1-922e-39ec43a0f839",
                    "leftValue": "={{ $json.url_plus_infos }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "AI Agent"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2ac0c6f1-b443-4468-96b5-263727ecb264",
                    "leftValue": "={{ $json.url_plus_infos }}",
                    "rightValue": "http",
                    "operator": {
                      "type": "string",
                      "operation": "startsWith"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "URL_plus_info"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        20,
        384
      ],
      "id": "31b088ad-c9a7-41c5-ba4c-35b4596935e2",
      "name": "Switch"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        -860,
        380
      ],
      "id": "b93f0ab0-2a63-41ed-972a-55aa97c19849",
      "name": "chatInput",
      "webhookId": "663a9e88-211b-461a-8b03-2819f26df10b"
    },
    {
      "parameters": {
        "jsCode": "// Parser universel pour Webhook1 ET chatInput (version corrigée)\nconst inputData = $input.first().json;\n\nconsole.log('=== PARSER UNIVERSEL ===');\nconsole.log('Type de données reçues:', typeof inputData);\nconsole.log('Clés disponibles:', Object.keys(inputData));\n\nlet outputData;\nlet sourceType = 'unknown';\n\ntry {\n  // DÉTECTION DE LA SOURCE PAR STRUCTURE DES DONNÉES\n  if (inputData.body && inputData.webhookUrl) {\n    // SOURCE: WEBHOOK1 direct\n    console.log('Source détectée: WEBHOOK1 (direct)');\n    outputData = inputData.body;\n    sourceType = 'webhook';\n    \n  } else if (inputData.chatInput !== undefined) {\n    // SOURCE: CHATINPUT  \n    console.log('Source détectée: CHATINPUT');\n    sourceType = 'chat';\n    \n    let chatData;\n    \n    // Parser le chatInput (toujours une string JSON)\n    if (typeof inputData.chatInput === 'string') {\n      chatData = JSON.parse(inputData.chatInput);\n      console.log('JSON string parsé avec succès');\n    } else {\n      chatData = inputData.chatInput;\n      console.log('Objet JSON déjà structuré');\n    }\n    \n    // Le chatInput contient un tableau avec les données webhook\n    if (Array.isArray(chatData) && chatData.length > 0) {\n      const firstItem = chatData[0];\n      console.log('Données extraites du tableau chatInput');\n      \n      if (firstItem.body) {\n        // Les vraies données sont dans body\n        outputData = firstItem.body;\n      } else {\n        // Fallback si structure différente\n        outputData = firstItem;\n      }\n    } else {\n      // Si ce n'est pas un tableau, utiliser directement\n      outputData = chatData;\n    }\n    \n  } else {\n    // SOURCE INCONNUE - Essayer de détecter\n    console.log('Source inconnue, tentative de détection...');\n    \n    if (inputData.aideDetails && inputData.projectContext) {\n      // Les données sont directement dans inputData\n      outputData = inputData;\n      console.log('Données détectées directement dans inputData');\n      sourceType = 'direct';\n    } else {\n      console.error('Format de données non reconnu');\n      return [{\n        json: {\n          error: true,\n          errorMessage: 'Format de données non reconnu',\n          availableKeys: Object.keys(inputData),\n          inputData: inputData\n        }\n      }];\n    }\n  }\n\n  // VALIDATION DE LA STRUCTURE\n  if (!outputData || !outputData.aideDetails || !outputData.projectContext) {\n    console.error('Structure de données incomplète');\n    console.log('OutputData reçu:', outputData);\n    \n    return [{\n      json: {\n        error: true,\n        errorMessage: 'Structure de données incomplète - aideDetails ou projectContext manquant',\n        receivedData: outputData,\n        sourceType: sourceType\n      }\n    }];\n  }\n\n  // RETOUR UNIFIÉ\n  console.log('✓ Parsing réussi');\n  console.log('Aide URL:', outputData.aideDetails?.url);\n  console.log('Projet ID:', outputData.projectContext?.projectId);\n\n  return [{\n    json: {\n      // Structure unifiée pour la suite du workflow\n      aideDetails: outputData.aideDetails,\n      projectContext: outputData.projectContext,\n      \n      // Métadonnées pour debug\n      _meta: {\n        sourceType: sourceType,\n        parsedAt: new Date().toISOString(),\n        hasKeyElements: !!outputData.projectContext?.key_elements\n      }\n    }\n  }];\n\n} catch (error) {\n  console.error('Erreur dans le parser universel:', error);\n  \n  return [{\n    json: {\n      error: true,\n      errorMessage: 'Erreur lors du parsing',\n      details: error.message,\n      inputData: inputData\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -640,
        280
      ],
      "id": "37eb13e0-9721-42e4-8310-6d1ba38ec80e",
      "name": "UniverselParse"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "c7ded2a8-7f53-4b61-a51b-47441a640641",
              "name": "pertinence",
              "value": "={{ $json.output }}",
              "type": "string"
            },
            {
              "id": "19d55b2a-cfe6-466b-84a0-bcd6e9f24bb9",
              "name": "receivedData.body.projectContext.projectId",
              "value": "={{ $('UniverselParse').item.json.receivedData.body.projectContext.projectId }}",
              "type": "string"
            },
            {
              "id": "a1dc14bd-8bcd-4723-87f0-544752d47d2f",
              "name": "receivedData.body.aideDetails.name",
              "value": "={{ $('UniverselParse').item.json.receivedData.body.aideDetails.name }}",
              "type": "string"
            },
            {
              "id": "fa23744c-646b-411e-be94-ecbad1bbe2f0",
              "name": "receivedData.body.aideDetails.url",
              "value": "={{ $('UniverselParse').item.json.receivedData.body.aideDetails.url }}",
              "type": "string"
            },
            {
              "id": "e6f5720f-2c0d-4c91-97d9-0cb42bf1df65",
              "name": "receivedData.body.aideDetails.id",
              "value": "={{ $('UniverselParse').item.json.receivedData.body.aideDetails.id }}",
              "type": "number"
            },
            {
              "id": "16e2179c-f9d7-4d7e-a6ed-554f8e170a76",
              "name": "porteur_aide",
              "value": "={{ $('Parser').item.json.porteur_aide }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1056,
        365.5
      ],
      "id": "eeb21138-a229-4dac-b267-a1ac0b578952",
      "name": "Edit Fields"
    }
  ],
  "pinData": {},
  "connections": {
    "AI Agent": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Parser",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook1": {
      "main": [
        [
          {
            "node": "UniverselParse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "URL_plus_info": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parser": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          },
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "URL_plus_info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "chatInput": {
      "main": [
        [
          {
            "node": "UniverselParse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "UniverselParse": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "ac14a572-db2b-47a1-9b45-3e7abd12a1c6",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "07ded2a5ddaa2e3ef818e39f2a91a69e11ab5e49fabe12ff8d8cad8daaff0acb"
  },
  "id": "QR8ZUQ0yzeLtNYGu",
  "tags": []
}